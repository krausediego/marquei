generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

enum MembershipRole {
  ADMIN
  STAFF
}

enum AppointmentStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
}

/// Estabelecimentos (barbearia/salão) — “tenant” do sistema. Agrupa serviços, profissionais, clientes e agenda.
model Establishment {
  id       String  @id @default(uuid()) @map("id")
  name     String  @map("name")
  phone    String? @map("phone")
  email    String? @map("email")
  address  String? @map("address")
  timezone String  @default("America/Sao_Paulo") @map("timezone")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  memberships   Membership[]
  services      Service[]
  professionals Professional[]
  clients       Client[]
  appointments  Appointment[]

  @@map("establishments")
}

/// Vínculo de um usuário do Keycloak com um estabelecimento + seu papel (ADMIN/STAFF) naquele estabelecimento.
model Membership {
  id              String         @id @default(uuid()) @map("id")
  establishmentId String         @map("establishment_id")
  keycloakUserId  String         @map("keycloak_user_id")
  role            MembershipRole @map("role")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  establishment Establishment @relation(fields: [establishmentId], references: [id], onDelete: Cascade)

  @@unique([establishmentId, keycloakUserId], map: "uq_memberships_establishment_keycloak_user")
  @@index([keycloakUserId], map: "idx_memberships_keycloak_user")
  @@map("memberships")
}

/// Serviços oferecidos pelo estabelecimento (ex.: corte, barba, sobrancelha), com duração e preço.
model Service {
  id              String  @id @default(uuid()) @map("id")
  establishmentId String  @map("establishment_id")
  name            String  @map("name")
  description     String? @map("description")
  durationMin     Int     @map("duration_min")
  priceCents      Int?    @map("price_cents")
  isActive        Boolean @default(true) @map("is_active")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  establishment Establishment @relation(fields: [establishmentId], references: [id], onDelete: Cascade)

  // Relations
  professionalServices ProfessionalService[]
  appointments         Appointment[]

  @@unique([establishmentId, name], map: "uq_services_establishment_name")
  @@index([establishmentId, isActive], map: "idx_services_establishment_active")
  @@map("services")
}

/// Profissionais que atendem no estabelecimento. Pode (opcionalmente) estar vinculado a um usuário do Keycloak para login no painel.
model Professional {
  id              String  @id @default(uuid()) @map("id")
  establishmentId String  @map("establishment_id")
  keycloakUserId  String? @map("keycloak_user_id")
  displayName     String  @map("display_name")
  phone           String? @map("phone")
  isActive        Boolean @default(true) @map("is_active")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  establishment Establishment @relation(fields: [establishmentId], references: [id], onDelete: Cascade)

  // Relations
  services     ProfessionalService[]
  appointments Appointment[]

  @@unique([establishmentId, keycloakUserId], map: "uq_professionals_establishment_keycloak_user")
  @@index([establishmentId, isActive], map: "idx_professionals_establishment_active")
  @@map("professionals")
}

/// Tabela de ligação (N:N) entre profissionais e serviços (quais serviços cada profissional realiza).
model ProfessionalService {
  professionalId String @map("professional_id")
  serviceId      String @map("service_id")

  createdAt DateTime @default(now()) @map("created_at")

  professional Professional @relation(fields: [professionalId], references: [id], onDelete: Cascade)
  service      Service      @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@id([professionalId, serviceId], map: "pk_professional_services")
  @@index([serviceId], map: "idx_professional_services_service")
  @@map("professional_services")
}

/// Clientes do estabelecimento, vinculados a um usuário do Keycloak. Guardam dados de perfil e histórico.
model Client {
  id              String  @id @default(uuid()) @map("id")
  establishmentId String  @map("establishment_id")
  keycloakUserId  String  @map("keycloak_user_id")
  fullName        String  @map("full_name")
  phone           String? @map("phone")
  email           String? @map("email")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  establishment Establishment @relation(fields: [establishmentId], references: [id], onDelete: Cascade)

  // Relations
  appointments Appointment[]
  reviews      Review[]

  @@unique([establishmentId, keycloakUserId], map: "uq_clients_establishment_keycloak_user")
  @@index([keycloakUserId], map: "idx_clients_keycloak_user")
  @@map("clients")
}

/// Agendamentos: liga cliente, profissional e serviço, com intervalo (início/fim) e status do atendimento.
model Appointment {
  id              String @id @default(uuid()) @map("id")
  establishmentId String @map("establishment_id")
  clientId        String @map("client_id")
  professionalId  String @map("professional_id")
  serviceId       String @map("service_id")

  // Guardar início e fim facilita MUITO conflito de horário (validado na aplicação).
  startsAt DateTime @map("starts_at")
  endsAt   DateTime @map("ends_at")

  status AppointmentStatus @default(PENDING) @map("status")
  notes  String?           @map("notes")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  establishment Establishment @relation(fields: [establishmentId], references: [id], onDelete: Cascade)
  client        Client        @relation(fields: [clientId], references: [id], onDelete: Restrict)
  professional  Professional  @relation(fields: [professionalId], references: [id], onDelete: Restrict)
  service       Service       @relation(fields: [serviceId], references: [id], onDelete: Restrict)

  review Review?

  // Observação:
  // conflito real (intervalos sobrepostos) é validado na aplicação.
  // Este unique evita duplicar o MESMO startsAt para o mesmo profissional.
  @@unique([professionalId, startsAt], map: "uq_appointments_professional_starts_at")
  @@index([establishmentId, startsAt], map: "idx_appointments_establishment_starts_at")
  @@index([professionalId, startsAt], map: "idx_appointments_professional_starts_at")
  @@index([clientId, startsAt], map: "idx_appointments_client_starts_at")
  @@map("appointments")
}

/// Avaliação do cliente sobre um atendimento (1..5), vinculada a um agendamento específico.
model Review {
  id            String @id @default(uuid()) @map("id")
  appointmentId String @unique(map: "uq_reviews_appointment") @map("appointment_id")
  clientId      String @map("client_id")

  rating  Int     @map("rating")
  comment String? @map("comment")

  createdAt DateTime @default(now()) @map("created_at")

  appointment Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  client      Client      @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId], map: "idx_reviews_client")
  @@map("reviews")
}
